"""Visualisations for feature sets experiments.

This script creates visualisations for the data generated by the
feature sets experiments (bin/exp-feature-sets.py)

The following naming convention for the plots is used:

    <1>--<2>--<3>--<4>--<5>.svg

Where:

    1. type of plot (lineplot, scatterplot, etc.)
    2. name of experiment
    3. name of dataset & protected attribute
    4. name of variables along x & y axis
    5. any other distinguishing keywords

Usage:
    TODO

The visualisations are saved as svg files under docs/ directory.

"""

import pandas as pd
import seaborn as sns
import os
import sys
import argparse

ROOTDIR = os.path.abspath(os.path.join(os.path.dirname(__file__), ".."))
DATADIR = os.path.join(ROOTDIR, "data")
ABREV = {"disparate_impact": "di", "statistical_parity_difference": "spd"}

sys.path.insert(0, ROOTDIR)
from src.data import process, pivot_frame
from src.visualise import savefig, gcfa, heatmap


def parse_args():
    """Parse command line arguments.

    In:
        None

    Returns:
        args: argparse.ArgumentParser
    """
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "dataset",
        help="Dataset & protected attribute in <dataset-pattr> format",
        choices=[
            "adult-sex",
            "adult-race",
            "compas-sex",
            "compas-race",
            "bank-age",
            "german-sex",
            "german-age",
            "meps-RACE",
        ],
    )

    parser.add_argument(
        "experiment",
        help="Name of experiment to use for visualisations",
        choices=[
            "feature-sets",
            "training-sets",
        ],
    )

    return parser.parse_args()


def lineplot(data, cols, x, name):
    """Create lineplot.

    TODO write description
    Args:
        data: pandas.Dataframe

    Returns:
        None

    """
    fig, axs = gcfa(ncols=len(cols))

    for idx, metric in enumerate(cols):
        ax = axs[idx]
        ax.set_ylabel(metric)
        sns.lineplot(
            data=data,
            x=x,
            y=metric,
            hue="model",
            style="model",
            ax=ax,
        )

    savefig(fig=fig, name=name)


def boxplot(data, cols, x, name):
    """Create boxplot.

    Args:
        data: pandas.DataFrame
        cols: List, colums of figure, passed to seaborn.boxplot.cols
        name: Str, name of figure
    """
    fig, axs = gcfa(ncols=len(cols), square=False)

    for idx, metric in enumerate(cols):
        ax = axs[idx]
        ax.set_ylabel(metric)
        sns.boxplot(
            data=data,
            x=x,
            y=metric,
            hue="model",
            dodge=True,
            ax=ax,
        )

    savefig(fig=fig, name=name)


def violinplot(data, cols, x, name):
    """Create violinplot.

    Args:
        data: pandas.DataFrame
        cols: List, columns of figure, passed to seaborn.violinplot.cols
        name: Str, name of figure
    """
    fig, axs = gcfa(ncols=len(cols), square=False)

    for idx, metric in enumerate(cols):
        ax = axs[idx]
        ax.set_ylabel(metric)
        sns.violinplot(
            data=data,
            x=x,
            y=metric,
            hue="model",
            dodge=True,
            ax=ax,
        )

    savefig(fig=fig, name=name)


def stripplot(data, cols, hue, name):
    fig, axs = gcfa(ncols=len(cols))

    for idx, metric in enumerate(cols):
        ax = axs[idx]
        ax.set_ylabel(metric)
        ax.tick_params(axis="x", labelrotation=90)
        sns.stripplot(
            data=data,
            x="model",
            y=metric,
            hue=hue,
            dodge=True,
            ax=ax,
        )
    savefig(fig, name)


def correlation_within_feature_sets(data, metric, col, name):
    """Create heatmap of correlations.

    Args:
        data: pandas.DataFrame
        cols: List, columns of figure, passed to seaborn.heatmap.cols
        name: Str, name of figure
    """
    values = data[col].unique().tolist()
    values.sort()  # we need this sorted in ascending order to
    # match order of axes returned by seaborn

    fig, axs = gcfa(
        grid={
            "data": data,
            "col": col,
        }
    )

    for idx, n in enumerate(values):
        ax = axs[idx]
        pivoted = pivot_frame(data=data[data[col] == n], values=metric)
        heatmap(data=pivoted, ax=ax)

    savefig(fig, name)


def correlation_across_feature_sets(data, cols, var, name):
    fig, axs = gcfa(ncols=len(cols))

    def pivot_data(data, values):
        _pivots = []
        for n in data[var].unique().tolist():
            _pivots.append(pivot_frame(data[data[var] == n], values))
        return pd.concat(_pivots)

    for idx, metric in enumerate(cols):
        ax = axs[idx]
        ax.set_title(metric)
        pivoted = pivot_data(
            data=data,
            values=metric,
        )
        heatmap(data=pivoted, ax=ax)

    savefig(fig, name)


def scatterplot_data_vs_model(data, cols, var, name):
    models = data["model"].unique().tolist()
    models.remove("None")
    fig, axs = gcfa(ncols=len(cols))

    def pivot_data(data, values):
        _pivots = []
        for val in data[var].unique().tolist():
            _pivot = pivot_frame(data[data[var] == val], values)
            _pivot[var] = val
            _pivots.append(_pivot)
        return pd.concat(_pivots)

    def stack_data(data, xs, ys):
        _stacks = []
        for x, y in zip(xs, ys):
            _stack = data[[x, y, var]]
            _stack = _stack.rename(columns={x: "x", y: "y"})
            _stack["model"] = y
            _stacks.append(_stack)
        return pd.concat(_stacks)

    for idx, metric in enumerate(cols):
        ax = axs[idx]
        ax.set_title(metric)
        ax.set_xlabel("data")
        ax.set_ylabel("model")
        pivoted_data = pivot_data(data=data, values=metric)
        stacked_data = stack_data(
            data=pivoted_data,
            xs=["None"] * len(models),
            ys=models,
        )
        sns.scatterplot(
            data=stacked_data,
            x="x",
            y="y",
            hue="model",
            ax=ax,
        )
    savefig(fig, name)


def regplot(data, cols, var, name):
    models = data["model"].unique().tolist()
    models.remove("None")

    def pivot_data(data, values):
        _pivots = []
        for n in data[var].unique().tolist():
            _pivot = pivot_frame(data[data[var] == n], values)
            _pivot[var] = n
            _pivot["metric"] = values
            _pivots.append(_pivot)
        return pd.concat(_pivots)

    def stack_data(data, xs, ys):
        _stacks = []
        for x, y in zip(xs, ys):
            _stack = data[[x, y, var, "metric"]]
            _stack = _stack.rename(columns={x: "x", y: "y"})
            _stack["model"] = y
            _stacks.append(_stack)
        return pd.concat(_stacks)

    _frames = []
    for metric in cols:
        pivoted_data = pivot_data(data=data, values=metric)
        stacked_data = stack_data(
            data=pivoted_data,
            xs=["None"] * len(models),
            ys=models,
        )
        _frames.append(stacked_data)
    new_data = pd.concat(_frames)

    g = sns.lmplot(
        data=new_data,
        x="x",
        y="y",
        hue="model",
        col="metric",
        sharey=True,
        sharex=False,
    )
    savefig(g, name)


if __name__ == "__main__":
    args = parse_args()

    dataset_label = args.dataset
    exp_label = args.experiment
    data = pd.read_csv(
        os.path.join(DATADIR, "exp-{}-{}-50.csv".format(exp_label, dataset_label))
    )
    # fairness metrics are calculated without conditioning on any
    # (un)privileged group
    data = data[data["privileged"] == "None"]
    process(data)
    cols = [
        "disparate_impact",
        "statistical_parity_difference",
    ]
    name = "--exp-{}--{}".format(exp_label, dataset_label)
    x = "num_features" if exp_label == "feature-sets" else "frac"

    # distribution plots

    name = "lineplot--exp-{}--{}--di-spd".format(exp_label, dataset_label)
    lineplot(
        data=data,
        cols=cols,
        x=x,
        name=name,
    )

    # NOTE the following boxplots & violinplots are not that useful & very "noisy"
    
    # name = "boxplot" + name + "--di-spd"
    # boxplot(
    #     data=data,
    #     cols=cols,
    #     x=x,
    #     name=name,
    # )

    # name = "violinplot--exp-feature-sets--{}--di-spd".format(dataset_label)
    # violinplot(
    #     data=data,
    #     cols=cols,
    #     name=name,
    # )

    # NOTE this scatterplot is very "noisy" & hard to interpret
    
    # name = "scatterplot" + name + "--di-spd"
    # stripplot(
    #     data=data,
    #     cols=cols,
    #     hue=x,
    #     name=name,
    # )

    # NOTE the linear regression plot already includes the scatterplot
    # so this one is not that useful
    
    # name = "scatterplot" + name + "--di-spd--data-vs-model"
    # scatterplot_data_vs_model(
    #     data=data,
    #     cols=cols,
    #     var=x,
    #     name=name,
    # )

    # NOTE these is no correlation between the model & data metrics
    # within each feature/training sets so the following plots do not
    # depict anything interesting

    # relationship plots

    # name = "heatmap" + name + "--{}".format(ABREV["disparate_impact"]) + "--within"
    # correlation_within_feature_sets(
    #     data=data,
    #     metric="disparate_impact",
    #     col=x,
    #     name=name,
    # )

    # name = "heatmap" + name + "--{}".format(ABREV["statistical_parity_difference"]) + "--within"
    # correlation_within_feature_sets(
    #     data=data,
    #     metric="statistical_parity_difference",
    #     col=x,
    #     name=name,
    # )

    # NOTE the following correlation plots are more useful, however we
    # are looking at the correlation across various feature/training
    # sets.

    # TODO Reflect on the pros & cons of this approach.
    name = "heatmap--exp-{}--{}--di-spd".format(exp_label, dataset_label)
    correlation_across_feature_sets(
        data=data,
        cols=cols,
        var=x,
        name=name,
    )
    name = "regplot--exp-{}--{}--di-spd".format(exp_label, dataset_label)
    regplot(
        data=data,
        cols=cols,
        var=x,
        name=name,
    )
